"""
RiftSage AI Agent - Report Compilation Lambda Function
Assembles all sections into a complete report
"""

import json
import os
import boto3
import logging
from datetime import datetime
from typing import Dict, List, Any

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS clients
dynamodb = boto3.resource('dynamodb')
s3_client = boto3.client('s3')

# Environment variables
ENVIRONMENT = os.environ.get('ENVIRONMENT', 'development')
INSIGHTS_TABLE_NAME = os.environ.get('INSIGHTS_TABLE')
REPORTS_BUCKET = os.environ.get('REPORTS_BUCKET')


def get_all_sections(player_puuid: str, year: int) -> List[Dict]:
    """Retrieve all generated sections for a player"""
    try:
        insights_table = dynamodb.Table(INSIGHTS_TABLE_NAME)

        # Query all sections for this player and year
        response = insights_table.query(
            KeyConditionExpression='player_puuid = :puuid',
            FilterExpression='#year = :year',
            ExpressionAttributeNames={'#year': 'year'},
            ExpressionAttributeValues={
                ':puuid': player_puuid,
                ':year': year
            }
        )

        sections = response.get('Items', [])

        logger.info(f"Found {len(sections)} sections for {player_puuid}")

        return sections

    except Exception as e:
        logger.error(f"Error retrieving sections: {str(e)}")
        return []


def compile_report(player_puuid: str, year: int) -> Dict:
    """Compile all sections into a complete report"""
    try:
        # Get all sections
        sections = get_all_sections(player_puuid, year)

        if not sections:
            raise ValueError("No sections found for player")

        # Organize sections by type
        section_map = {}
        for section in sections:
            section_type = section.get('section_type')
            section_map[section_type] = {
                'type': section_type,
                'content': section.get('content', ''),
                'generated_at': section.get('generated_at'),
                'section_id': section.get('section_id')
            }

        # Define section order
        section_order = [
            'role_performance',
            'improvement_blueprint',
            'mental_resilience',
            'champion_mastery'
        ]

        # Build complete report
        complete_report = {
            'player_puuid': player_puuid,
            'year': year,
            'title': f'League of Legends {year} Performance Report',
            'generated_at': datetime.utcnow().isoformat(),
            'sections': []
        }

        for section_type in section_order:
            if section_type in section_map:
                complete_report['sections'].append(section_map[section_type])

        return complete_report

    except Exception as e:
        logger.error(f"Error compiling report: {str(e)}")
        raise


def generate_json_report(report_data: Dict) -> str:
    """Generate JSON format report"""
    return json.dumps(report_data, indent=2)


def generate_markdown_report(report_data: Dict) -> str:
    """Generate Markdown format report"""
    try:
        markdown = f"""# {report_data['title']}

**Player:** {report_data['player_puuid']}
**Year:** {report_data['year']}
**Generated:** {report_data['generated_at']}

---

"""

        section_titles = {
            'role_performance': '## Role Performance Snapshot',
            'improvement_blueprint': '## Improvement Blueprint',
            'mental_resilience': '## Mental Resilience & Consistency',
            'champion_mastery': '## Champion Mastery Analysis'
        }

        for section in report_data['sections']:
            section_type = section['type']
            title = section_titles.get(section_type, f"## {section_type.title()}")

            markdown += f"{title}\n\n"
            markdown += f"{section['content']}\n\n"
            markdown += "---\n\n"

        markdown += f"""
## Report Information

- **Generated At:** {report_data['generated_at']}
- **Environment:** {ENVIRONMENT}
- **Version:** 1.0

---

*Generated by RiftSage AI Agent*
"""

        return markdown

    except Exception as e:
        logger.error(f"Error generating markdown: {str(e)}")
        raise


def save_report_to_s3(player_puuid: str, year: int, report_data: Dict) -> Dict:
    """Save report to S3 in multiple formats"""
    try:
        results = {}

        # Generate JSON
        json_content = generate_json_report(report_data)
        json_key = f"reports/{player_puuid}/{year}/report.json"

        s3_client.put_object(
            Bucket=REPORTS_BUCKET,
            Key=json_key,
            Body=json_content,
            ContentType='application/json',
            Metadata={
                'player_puuid': player_puuid,
                'year': str(year),
                'generated_at': datetime.utcnow().isoformat()
            }
        )

        results['json'] = {
            'key': json_key,
            'size': len(json_content)
        }

        # Generate Markdown
        markdown_content = generate_markdown_report(report_data)
        markdown_key = f"reports/{player_puuid}/{year}/report.md"

        s3_client.put_object(
            Bucket=REPORTS_BUCKET,
            Key=markdown_key,
            Body=markdown_content,
            ContentType='text/markdown',
            Metadata={
                'player_puuid': player_puuid,
                'year': str(year),
                'generated_at': datetime.utcnow().isoformat()
            }
        )

        results['markdown'] = {
            'key': markdown_key,
            'size': len(markdown_content)
        }

        # Generate presigned URLs (valid for 7 days)
        json_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': REPORTS_BUCKET, 'Key': json_key},
            ExpiresIn=604800
        )

        markdown_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': REPORTS_BUCKET, 'Key': markdown_key},
            ExpiresIn=604800
        )

        results['urls'] = {
            'json': json_url,
            'markdown': markdown_url
        }

        logger.info(f"Saved report to S3: {json_key}, {markdown_key}")

        return results

    except Exception as e:
        logger.error(f"Error saving to S3: {str(e)}")
        raise


def lambda_handler(event, context):
    """
    Lambda handler for report compilation

    Event format:
    {
        "player_puuid": "string",
        "year": 2025
    }
    """

    try:
        logger.info(f"Event: {json.dumps(event, default=str)}")

        player_puuid = event.get('player_puuid')
        year = event.get('year', datetime.utcnow().year)

        if not player_puuid:
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'player_puuid is required'})
            }

        # Compile report
        logger.info(f"Compiling report for {player_puuid}, year {year}")
        report_data = compile_report(player_puuid, year)

        # Save to S3
        logger.info("Saving report to S3")
        s3_results = save_report_to_s3(player_puuid, year, report_data)

        return {
            'statusCode': 200,
            'body': json.dumps({
                'success': True,
                'player_puuid': player_puuid,
                'year': year,
                'sections_count': len(report_data['sections']),
                's3_results': s3_results,
                'generated_at': report_data['generated_at']
            })
        }

    except Exception as e:
        logger.error(f"Lambda handler error: {str(e)}", exc_info=True)
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': str(e),
                'type': type(e).__name__
            })
        }
